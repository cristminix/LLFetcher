const f=async(e,c,r)=>{const t=r.transaction(e,"readonly"),n=t.objectStore(e);return new Promise((o,s)=>{t.oncomplete=function(){},t.onerror=function(){};let a=n.get(c);a.onsuccess=function(i){o(i.target.result)}})},j=async(e,c,r)=>{const t=r.transaction(e,"readwrite"),n=t.objectStore(e);return new Promise((o,s)=>{if(t.oncomplete=function(){o(!0)},t.onerror=function(){o(!1)},Array.isArray(c))c.forEach(a=>{let i=n.add(a);i.onsuccess=function(){}});else{const a=c;let i=n.add(a);i.onsuccess=function(){}}})},m=async(e,c,r)=>{const t=r.transaction(e,"readwrite"),n=t.objectStore(e);return new Promise((o,s)=>{t.oncomplete=function(){o(!0)},t.onerror=function(){s(!1)},n.put(c)})},p=async(e,c,r,t)=>{const n=t.transaction(e,"readwrite"),o=n.objectStore(e);return new Promise((s,a)=>{n.oncomplete=function(){s(!0)},n.onerror=function(){s(!1)},r?o.clear():o.delete(c)})},y=async(e="main")=>new Promise((c,r)=>{const t=indexedDB.open(e);t.onerror=n=>{r(n)},t.onsuccess=n=>{c(n.target.result)}}),S=async(e,c="main")=>new Promise((r,t)=>{const n=indexedDB.open(c);n.onupgradeneeded=function(o){const s=o.target.result;if(Array.isArray(e))e.map((a,i)=>{const{name:u,keyPath:d}=a,l=s.createObjectStore(u,{keyPath:d});l.transaction.oncomplete=b=>{console.log(`object store ${u} : created`),i===e.length-1&&r(s)}});else{const{name:a,keyPath:i}=e,u=s.createObjectStore(a,{keyPath:i});u.transaction.oncomplete=d=>{console.log(`object store ${a} : created`),r(s)}}},n.onerror=o=>{t(o)},n.onsuccess=o=>{r(o.target.result)}}),_=e=>e.close();export{m as a,j as b,p as c,S as d,y as e,_ as f,f as i};
